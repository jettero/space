# Repository Guidelines

## Project Structure & Module Organization
- Package code: `space/` (see `setup.cfg` and `pyproject.toml`).
- Tests: `t/` (configured via `pytest.ini:testpaths = t`).
- Build artifacts: `build/`, `dist/`, `space.egg-info/`.
- Config/tooling: `Makefile`, `pytest.ini`, `.pre-commit-config.yaml`,
  `pylintrc`.
- Requirements: `requirements.txt` (runtime), `test-requirements.txt`
  (dev/test). Markers: `reqs`, `mods`.

## Build, Test, and Development Commands
- `make` or `make test` — run test suite (`pytest t`).
- Parallel runs: prefer using available CPUs instead of a fixed `-j`.
  - Examples: `make test -j"$(nproc)"` (Linux), `make test -j"$(sysctl -n
    hw.ncpu)"` (macOS), or set `-j16` if you know your core count.
  - Avoid small fixed values like `-j2` on multi-core machines.
- `pre-commit run --all-files` — run linters/formatters (pylint, black, hooks).
- `python -m build` — build sdist/wheel (also via `make build`) when cutting
  releases.
- `pip install -Ur test-requirements.txt` — install test-only deps if needed
  (`make reqs`).

## Coding Style & Naming Conventions
- Lint: `pylint` (configured by `pylintrc`). Format: `black` (via pre-commit).
- Indentation: 4 spaces; UTF-8; Unix newlines.
- Naming: modules `snake_case.py`; classes `CamelCase`; functions/vars
  `snake_case`; constants `UPPER_SNAKE`.
- Keep modules focused; prefer small, testable functions. Type hints encouraged
  for public APIs.

### Markdown Formatting
- Wrap Markdown text at ~80 characters per line.
- Keep prose concise; avoid unnecessary verbosity.

### Map/Generator Conventions
- Floors: use `Floor` for room interiors, `Corridor` for hallways; both subclass
  `Cell` and render the same by default.
- Walkability checks: use `isinstance(x, Cell)` instead of checking subclasses.
- Partition smoothing: `Map.cellify_partitions()` opens partitions as `Corridor`
  tiles; keep docstrings brief.
- Color: default colorized output treats floors/corridors with the same grey
  (`boring_color`). Avoid per-type hues unless explicitly requested.

## Testing Guidelines
- Framework: `pytest` (see `pytest.ini` for `-v --ff --show-capture=stderr
  --maxfail=1`).
- Tests live in `t/`; name files `test_*.py`. Use `-k name` for focused runs.
- Keep tests deterministic; avoid network; isolate I/O (tmp paths/fixtures).
- Run `make test` before commits. Prefer small, verifiable changes; avoid
  unrelated fixes in the same patch.

### Test Style
- Prefer assertive code over comments; keep tests self-explanatory.
- When asserting exceptions, use `pytest.raises(..., match=regex)` to check
  the error message, not just the type.
- For parse failures, assert `not pstate`, `pstate.winner is None`, and check
  any available `pstate.error` text when relevant.

### Test Naming
- Use concise, descriptive function names that encode input and outcome.
- Positive parse cases: `test_open_door`, `test_open_south_door`.
- Negative parse cases end with `_fail`/`_fails`:
  `test_open_north_door_fail`, `test_open_nonsense_fails`.
- Multi-step flows describe the sequence succinctly:
  `test_open_door_and_move_through_it`.

## Commit & Pull Request Guidelines
- Commits: imperative subject line (<=72 chars); explain rationale when
  non-trivial.
- Keep diffs focused; reference issues (e.g., `Fixes #123`).
- PRs: include summary, motivation, test coverage, and any UX/build notes or
  screenshots.
- CI must pass: tests (`make test`) and hooks (`pre-commit`).

## Notes on Versioning & Build
- Version is generated by `setuptools_scm` into `space/version.py` (see
  `pyproject.toml`).
- Do not edit `space/version.py` manually; tag releases via Git to bump version
  metadata.
- For local development, do not install the package; run tests directly via
  `make test`.

## Agent Tips
- Be concise. Add minimal docstrings that explain purpose and key args; avoid
  long narratives.
- When adding flags like `cellify_partitions=True`, document with a very short
  phrase (e.g., "open short partitions").
- Prefer surgical changes; don’t refactor broadly unless asked.
- Respect `pytest.ini` settings; use `rg` for repo scans; read files in
  ≤250-line chunks.
- Only add code comments when they materially improve clarity. Avoid
  redundant or obvious comments; keep necessary comments short and direct.
 - Do not add conversational or meta comments in code. Comments must be about
   the code itself, not about prior discussion or rationale external to the
   codebase.
- We favor TDD: add a failing test first, then implement the minimal
  code to make it pass. Keep tests focused, deterministic, and aligned with
  the current map/verb conventions.

### Robustness vs. Known Types
- When implementing verbs that operate on known engine types (e.g., `Living`),
  avoid defensive `getattr/hasattr` checks for attributes guaranteed by the
  type (e.g., `level`, `xp`, `hp`, `gender`, `height`, `weight`, `initiative`).
  If the parser allows invoking a verb on a player character, those attributes
  exist. Prefer direct attribute access to keep code clear and fail fast on
  actual programmer errors.

### Parser/Verb Tasks
- Before implementing or modifying verbs, skim `PARSER.md` for naming and
  routing conventions (e.g., `can_<verb>_obj` implies StdObj matching).
- Prefer using the shell for compound commands in tests (e.g.,
  `me.do('open door; sSW6s3w')`).
- Do not change router hint logic in `space/args.py` to fit a single verb.
  Instead, follow the parameter naming conventions described in `PARSER.md`.

## Maintainer Preferences (Session Learnings)

- Small, clear fixes: proceed without asking; validate with focused tests.
- Tests: prefer concise, targeted tests; avoid relying on complex fixtures
  when simpler environment-specific fixtures exist (e.g., use `e_map` over
  `a_map` for unobstructed movement).
- Assertions: use `assert ps` for `PState` truthiness; avoid tuple messages
  like `assert ps, ps.error`.
- Comments: avoid adding comments unless necessary for code clarity; keep any
  comments short and about the code only.

## Messaging System (Planning Notes)

- Source of inspiration: `contrib/m_messages.c` (LPC). Treat it as a reference
  for concepts only; port behavior into idiomatic Python within `space/`.
- Placement: prefer a small `MessagesMixin` integrated into `Living`/`Humanoid`
  (likely on `Humanoid`) rather than a new global system. Keep surface area
  minimal and reuse existing shells and message types in `space/shell/`.
- Composition vs delivery: separate message composition (token expansion like
  `$N`, `$vverb`, `$t`, pronouns/possessives, and basic agreement) from
  delivery. Composition should return `TextMessage` instances; delivery should
  call `.tell()` on participants and nearby observers.
- Nearby delivery: fan‑out to “others” via the map/cell containers already in
  `space/map/cell/`. If a helper is required, add a minimal method on `Cell`
  to enumerate adjacent cells/occupants for audience collection. Avoid broad
  registries or globals.
- Grammar tokens: start with a practical subset: subjects `$N/$n`, target
  `$T/$t`, objects `$O/$o`, possessive/objective/reflexive `$p/$o/$r`, and
  verb agreement `$vverb`. Expand incrementally alongside tests.
- Gender/pronouns: follow the current `Living` gender model. Do not add
  defensive checks for attributes guaranteed by `Living` (e.g., `gender`,
  pronoun accessors once defined). Prefer direct attribute access.
- Shell integration: reuse `space/shell/message.TextMessage` and the existing
  `Living.tell()` plumbing (`HasShell.shell.receive`). Avoid introducing new
  sinks; format once, then deliver.
- Minimal environment changes: only add what’s needed to enumerate nearby
  `MessagesMixin` receivers. Floors and corridors should remain visually the
  same; any helper should be short and generic.
- Tests first: add focused tests in `t/` covering token expansion, agreement,
  self/target/others variants, and adjacency fan‑out. Keep tests deterministic
  and avoid router changes.
- Keep Pythonic: small pure functions for token parsing/expansion; avoid hidden
  globals. Any defaults/templates live on the mixin/class, not modules.

## Git Usage Policy

- Using `git diff` and `git log` for context is encouraged.
- Do not run `git commit`, `git add`, or `git reset` from the agent under any circumstances.
- Do not use `git mv`. Just move files with `mv`; I will manage the repo myself
- in general, you're welcome to use git to gain insight into the code, but you
  may only do so in a read only fashion

## Python Version & Style Notes

- Target runtime: Python 3.8+ semantics, but avoid modern annotation syntax in
  function signatures (no `def fn(...) -> T` or union `A | B`).
- Prefer classic style definitions without return‑type annotations. Use docstrings
  or comments for type hints where helpful.
